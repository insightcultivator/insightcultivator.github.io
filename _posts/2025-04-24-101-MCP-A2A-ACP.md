---
title: 34차시 1:MCP,A2A,ACP
layout: single
classes: wide
categories:
  - MCP,A2A,ACP
toc: true # 이 포스트에서 목차를 활성화
toc_sticky: true # 목차를 고정할지 여부 (선택 사항)
---

## 1. AI 에이전트 통신 프로토콜 비교
- 출처: [Anthropic MCP vs Google A2A vs IBM ACP](https://www.youtube.com/watch?v=iV3Iesez2s8)

### **1.1 개요**

* 현재 빠르게 진화하고 있는 AI 에이전트 생태계에서, 각 에이전트가 외부 세계의 다양한 요소들과 효율적으로 소통하고, 다른 지능적인 에이전트들과 원활하게 협력하는 방식의 근간을 이루는 핵심 통신 프로토콜들을 소개합니다. 이러한 프로토콜들은 AI 에이전트의 기능 확장과 복잡한 문제 해결 능력 향상에 필수적인 역할을 수행합니다.
* 본 보고서에서는 AI 에이전트 통신 프로토콜 분야를 선도하는 세 가지 주요 프로토콜, 즉 Anthropic의 혁신적인 MCP (Model Context Protocol), Google의 상호 운용성을 강조하는 A2A (Agent-to-Agent Protocol), 그리고 IBM의 실용적인 접근 방식을 담은 ACP (Agent Communication Protocol)를 심층적으로 비교 분석합니다. 각 프로토콜의 설계 철학, 기술적 특징, 그리고 잠재적인 영향력을 다각적으로 조명하여 독자들의 이해를 돕고자 합니다.

### **1.2 주요 내용**

1.  **AI 에이전트 생태계의 표준화 긴급성:**
    * 최근 몇 년간 Langchain, Crew AI, Autogen 등 다양한 AI 에이전트 개발 프레임워크의 등장으로 인해 생태계가 빠르게 확장되었지만, 동시에 각 프레임워크 간의 호환성 부족으로 인한 심각한 파편화 문제가 발생하고 있습니다. 이는 개발의 비효율성을 야기하고, 다양한 에이전트 간의 협업을 어렵게 만드는 주요 원인으로 작용합니다.
    * 이러한 파편화 문제를 해결하고 AI 에이전트 생태계의 성장을 가속화하기 위해서는 다음과 같은 핵심 영역에서의 표준화가 시급히 요구됩니다.
        * **에이전트의 도구 및 데이터 접근 방식:** 
            - 각 에이전트가 외부의 다양한 도구 (예: 검색 엔진, 계산기, API)와 데이터 소스 (예: 데이터베이스, 웹 페이지, 파일 시스템)에 일관된 방식으로 접근하고 활용할 수 있도록 표준화된 인터페이스 및 절차가 필요합니다. 이를 통해 개발자는 특정 프레임워크에 종속되지 않고 다양한 도구와 데이터를 통합하는 에이전트를 보다 쉽게 구축할 수 있습니다.
        * **에이전트 간 통신 방식:** 
            - 서로 다른 AI 에이전트들이 정보를 교환하고 협력하여 공동의 목표를 달성할 수 있도록 표준화된 메시지 형식, 통신 프로토콜, 그리고 상호 작용 패턴이 정의되어야 합니다. 이는 복잡한 작업을 분담하고, 각 에이전트의 전문성을 활용하여 보다 효율적인 문제 해결을 가능하게 합니다.
        * **자연어 처리 방식 (불명확한 인간의 지시 처리):** 
            - 인간의 자연어 지시는 종종 모호하거나 다의적일 수 있습니다. AI 에이전트가 이러한 불명확한 지시를 정확하게 이해하고 적절하게 대응할 수 있도록 자연어 처리 과정에서의 표준화된 접근 방식과 해석 규칙이 필요합니다. 이는 사용자 경험을 향상시키고, AI 에이전트의 신뢰성을 높이는 데 중요한 역할을 합니다.

2.  **주요 프로토콜의 상세 특징:**
    * **MCP (Model Context Protocol, Anthropic):**
        * Anthropic에서 제안하는 MCP는 대규모 언어 모델(LLM)이 작업을 수행하는 데 필요한 다양한 컨텍스트 정보를 효율적이고 안전하게 제공하는 데 초점을 맞춘 프로토콜입니다. 이는 LLM의 성능을 극대화하고, 외부 세계와의 상호 작용을 원활하게 하기 위한 핵심적인 메커니즘을 제공합니다.
        * MCP는 크게 세 가지 주요 구성 요소인 MCP 호스트, MCP 클라이언트, 그리고 MCP 서버로 구성됩니다. MCP 호스트는 LLM을 실행하고 관리하는 환경을 제공하며, MCP 클라이언트는 외부 도구나 데이터 소스를 LLM과 연결하는 역할을 수행합니다. MCP 서버는 이러한 연결을 중개하고 필요한 데이터를 안전하게 제공합니다.
        * MCP의 핵심 특징 중 하나는 프롬프트(사용자가 LLM에 내리는 지시), 리소스(애플리케이션이 제공하는 정보), 그리고 도구(LLM이 사용할 수 있는 외부 기능)를 명확하게 분리하여 관리한다는 점입니다. 이러한 분리를 통해 각 요소의 역할을 명확히 하고, 정보 흐름을 효율적으로 제어하며, 잠재적인 보안 위험을 줄일 수 있습니다.
        * MCP는 GitHub, Slack, Gmail과 같은 널리 사용되는 서비스뿐만 아니라, 데이터베이스, API, 로컬 파일 시스템 등 다양한 유형의 외부 서비스와의 유연한 연결을 지원합니다. 이를 통해 LLM은 광범위한 정보와 기능을 활용하여 더욱 강력하고 다양한 작업을 수행할 수 있습니다.
        * 중요한 점은 MCP가 기존의 AI 에이전트 개발 도구나 프레임워크를 직접적으로 대체하는 것을 목표로 하지 않는다는 것입니다. 오히려 다양한 도구와 프레임워크를 LLM과 연결하기 위한 공통의 표준을 제공함으로써, 기존 시스템과의 원활한 통합을 추구합니다.
    * **A2A (Agent-to-Agent Protocol, Google):**
        * Google에서 제안하는 A2A 프로토콜은 서로 다른 AI 에이전트들이 독립적으로 작동하면서도, 필요에 따라 효과적으로 협력하여 복잡한 목표를 달성할 수 있도록 표준화된 통신 방식을 제공하는 데 중점을 둡니다. 이는 다중 에이전트 시스템의 구축 및 운영을 위한 핵심적인 기반 기술입니다.
        * A2A 프로토콜은 MCP와 상호 보완적인 관계를 가지며, MCP가 LLM과 외부 세계의 연결을 용이하게 하는 반면, A2A는 여러 에이전트 간의 상호 작용 및 정보 교환을 표준화합니다.
        * A2A는 클라이언트 역할을 하는 에이전트와 원격으로 존재하는 에이전트 간의 통신을 지원합니다. 이를 통해 다양한 환경에서 실행되는 에이전트들이 서로 협력하여 작업을 수행할 수 있습니다.
        * A2A 프로토콜의 주요 설계 원칙은 다음과 같습니다.
            * **에이전트 능력 중심 설계:** 각 에이전트가 어떤 기능을 수행할 수 있는지 명확하게 정의하고, 이를 기반으로 통신 및 협업이 이루어지도록 설계되었습니다.
            * **기존 웹 표준 기반:** HTTP, JSON 등 널리 사용되는 웹 표준을 활용하여 구현되었으며, 이는 프로토콜의 확장성과 상호 운용성을 높이는 데 기여합니다.
            * **기본적인 보안 메커니즘 내장:** 에이전트 간 통신 과정에서 기본적인 인증 및 권한 관리 기능을 제공하여 보안을 강화합니다.
            * **장기 실행 작업 지원:** 시간이 오래 걸리는 비동기적인 작업의 처리 및 결과 공유를 위한 메커니즘을 제공하여, 복잡한 작업을 안정적으로 수행할 수 있도록 지원합니다.
            * **콘텐츠 형식 불가지론:** 전송되는 메시지의 내용 형식에 제약을 두지 않아, 다양한 종류의 정보 (텍스트, 이미지, 데이터 등)를 유연하게 교환할 수 있도록 설계되었습니다.
        * A2A 프로토콜의 주요 기능은 다음과 같습니다.
            * **에이전트 카드:** 각 에이전트의 이름, 설명, 제공하는 기능, 통신 방식 등을 JSON 형식으로 정의한 메타데이터입니다. 클라이언트 에이전트는 이 에이전트 카드를 통해 원격 에이전트의 능력을 검색하고, 협업 가능성을 파악할 수 있습니다.
            * **작업 완료 중심 통신:** 에이전트 간의 통신은 특정 작업을 요청하고 그 결과를 받는 방식으로 이루어집니다. 이는 통신의 목적을 명확히 하고, 효율적인 협업을 가능하게 합니다.
            * **메시지 기반 정보 전달:** 에이전트 간에는 메시지를 통해 컨텍스트 정보, 질의, 답변, 작업 결과, 사용자 지시 등 다양한 정보를 주고받을 수 있습니다.
    * **ACP (Agent Communication Protocol, IBM):**
        * IBM에서 제안하는 ACP는 AI 에이전트 간의 효과적인 통신을 위한 표준을 구축하여, 자동화된 워크플로우, 에이전트 간 협업, 사용자 인터페이스 통합, 그리고 개발자 도구 지원을 용이하게 하는 것을 목표로 합니다.
        * ACP의 특징적인 접근 방식은 점진적인 표준화입니다. 즉, AI 에이전트 생태계에서 실제로 유용하게 사용될 수 있는 기능들을 먼저 개발하고, 그 성과를 바탕으로 점차적으로 표준화 범위를 확장해 나가는 방식을 취합니다. 이는 초기 단계부터 완벽한 표준을 정의하는 것보다 실용적인 이점을 제공하고, 기술 변화에 유연하게 대응할 수 있도록 합니다.
        * ACP는 자연어 처리의 유연성을 최대한 활용하고, 특정 모델에 대한 의존성을 줄이는 데 중점을 둡니다. 이는 다양한 언어 모델 환경에서 ACP를 적용할 수 있도록 하고, 모델 변경에 따른 시스템의 안정성을 높이는 데 기여합니다.

3.  **프로토콜 심층 비교:**

| 기준             | MCP (Anthropic)                                                                 | A2A (Google)                                                                     | ACP (IBM)                                                                         |
| :--------------- | :------------------------------------------------------------------------------ | :------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------- |
| **핵심 목적** | LLM에 필요한 컨텍스트를 효율적이고 안전하게 제공 (외부 도구 및 데이터 연결 중심) | 독립적인 에이전트 간의 원활한 협업을 위한 표준 통신 방식 제공                     | AI 에이전트 통신 표준화를 통한 자동화, 협업, UI 통합 및 개발 편의성 증진 (자연어 처리 및 모델 독립성 강조) |
| **아키텍처** | 프롬프트, 리소스, 도구의 명확한 분리 및 관리 (호스트-클라이언트-서버 모델)       | 클라이언트 에이전트와 원격 에이전트 간의 작업 요청 및 응답 중심 통신 (에이전트 카드 활용) | 점진적 기능 개발 및 표준화, 자연어 유연성 및 모델 의존성 관리를 위한 설계              |
| **생태계 및 도입** | Anthropic의 LLM 플랫폼을 중심으로 다양한 도구 및 애플리케이션과의 통합 사례 증가 | 2025년 생산 버전 출시 예정으로, Google의 다양한 AI 서비스와의 연동 가능성 높음     | 초기 개발 단계로, 구체적인 적용 사례는 아직 제한적일 수 있음                       |
| **보안 및 인증** | 프롬프트, 리소스, 도구 분리를 통한 잠재적 보안 위험 감소 노력, 구체적인 인증 방식에 대한 정보는 제한적 | 엔터프라이즈 환경을 고려한 수준 높은 인증 및 권한 관리 메커니즘 지원                 | 보안 및 인증 관련 구체적인 정보는 아직 공개되지 않았을 가능성이 높음                |
| **잠재적 경쟁/중복** | A2A 및 ACP가 에이전트 간 통신 기능을 강화함에 따라 장기적으로 기능 중복 또는 경쟁 심화 가능성 존재 | MCP가 에이전트 간 통신 기능을 일부 지원할 가능성이 있으나, 핵심 목표는 다름        | MCP 및 A2A와 목표 및 설계 철학이 일부 겹칠 수 있으나, 자연어 처리 및 모델 독립성 강조라는 차별점 존재 |

* **개발자 및 비즈니스 리더를 위한 전략적 권장 사항:**
    * **MCP:** 
        - 현재 Anthropic의 LLM을 활용하여 AI 에이전트를 개발하고 있으며, 다양한 외부 도구, 데이터 소스, 또는 기존 시스템과의 안전하고 효율적인 연결이 중요한 경우에 MCP를 우선적으로 고려해 볼 수 있습니다. 특히, 명확하게 분리된 컨텍스트 관리를 통해 LLM의 성능을 최적화하고 싶을 때 유용합니다.
    * **A2A:** 
        - 여러 AI 에이전트가 협력하여 복잡한 작업을 수행하는 다중 에이전트 시스템을 구축하고자 하거나, 서로 다른 프레임워크 또는 벤더의 에이전트 간 상호 운용성이 중요한 경우에 A2A 프로토콜의 도입을 적극적으로 검토해 볼 필요가 있습니다. 특히, 2025년 생산 버전 출시를 앞두고 있어, 향후 Google의 다양한 AI 서비스와의 통합 가능성을 염두에 두는 것이 좋습니다.
    * **ACP:** 
        - 자연어 처리의 유연성을 확보하고 특정 언어 모델에 대한 의존성을 최소화하는 것이 중요한 사용 사례에 주목할 필요가 있습니다. IBM의 ACP는 아직 초기 개발 단계이지만, 장기적인 관점에서 다양한 모델 환경에서의 안정적인 AI 에이전트 구축을 고려하는 개발자 및 비즈니스 리더에게 잠재적인 가치를 제공할 수 있습니다.

### **1.3 결론**

- AI 에이전트 통신 프로토콜은 아직 발전 초기 단계에 있지만, 다양한 AI 시스템 간의 상호 운용성을 획기적으로 향상시키고, 더욱 강력하고 유연한 AI 생태계를 구축하는 데 필수적인 기반 기술입니다. 
- 현재 제시되고 있는 MCP, A2A, ACP는 각기 다른 목표와 접근 방식을 가지고 있지만, 궁극적으로 AI 에이전트의 잠재력을 최대한으로 끌어올리는 데 기여할 것입니다. 
- 개발자와 비즈니스 리더는 각 프로토콜의 특징과 장단점을 명확히 이해하고, 자신들의 특정 요구 사항과 전략적 목표에 가장 적합한 프로토콜을 신중하게 선택하고 적용해야 할 것입니다. 앞으로 이러한 표준들이 어떻게 발전하고 통합되어 나갈지 지속적으로 주목할 필요가 있습니다.

## 2. Google Agent Development Kit (ADK) 핵심
- 출처: [Google Agent Development Kit (ADK) Full Review with Examples](https://www.youtube.com/watch?v=OlfjWonfcQ4)

### **2.1 개요**

* Google에서 야심차게 선보인 최신 **오픈 소스** 에이전트 프레임워크입니다. 이는 개발자들이 더욱 쉽고 빠르게 **AI 에이전트를 구축**하여 생산성을 획기적으로 향상시키는 것을 목표로 합니다.
* 특히 Google의 최첨단 **Gemini 모델과 긴밀하게 통합**되어 강력한 AI 기능을 에이전트 개발에 용이하게 활용할 수 있도록 설계되었습니다.

### **2.2 주요 내용**

1.  **ADK란?**
    * 단순히 정보를 제공하는 것을 넘어 **실제 작업을 수행할 수 있는** 지능형 AI 어시스턴트를 제작하기 위한 **개발 도구 모음**입니다.
    * **LLM (Large Language Model)의 뛰어난 텍스트 이해 능력**과 외부 도구나 시스템을 연결하여 **실질적인 행동을 수행**할 수 있도록 지원합니다.
    * 개발자는 ADK를 통해 **특정 목표와 지침을 가진 에이전트를 명확하게 정의**하고, 이를 통해 **정보 확인, 시스템 업데이트, 심지어 실제 세계에서의 행동 수행**까지 가능하게 됩니다.
    * 또한, 에이전트가 다양한 도구를 효율적으로 사용하고, 사용자 및 시스템과의 **대화 과정을 체계적으로 추적하고 관리**할 수 있는 **세션 관리 기능**을 제공합니다.

2.  **ADK 핵심 기능**
    1. **에이전트 유형:** 개발 목적과 필요한 기능에 따라 다양한 유형의 에이전트를 선택하고 조합.
        * **LLM 에이전트:** 
            - Gemini, Claude, Llama 등 다양한 **LLM을 핵심 두뇌로 활용**하는 에이전트입니다. 복잡한 추론, 자연어 이해, 창의성이 요구되는 작업 (예: 고객 질문에 대한 심층적인 답변, 광범위한 주제에 대한 리서치 등)에 **높은 유연성과 지능**을 제공합니다.
        * **워크플로우 에이전트:** **LLM 없이** 미리 정의된 명확한 작업 흐름 (workflow)에 따라 **다른 에이전트들의 실행을 체계적으로 제어**하는 에이전트입니다. 예측 가능하고 반복적인 작업 자동화에 유용.
            * **Sequential 에이전트:** 
                - 여러 하위 에이전트를 **정해진 순서대로 차례대로 실행**합니다. 마치 조립 라인과 같이 단계별 작업 처리에 적합합니다.
            * **Loop 에이전트:** 
                - 특정 **조건이 충족될 때까지 하나 또는 여러 하위 에이전트를 반복적으로 실행**합니다. 데이터 수집이나 특정 목표 달성을 위한 반복 작업에 유용합니다.
            * **Parallel 에이전트:** 
                - 여러 하위 에이전트를 **동시에 병렬적으로 실행**하여 작업 처리 속도를 극대화합니다. 독립적인 여러 작업을 동시에 처리해야 할 때 효율적입니다.
        * **Custom 에이전트:** 
            - 기본적인 에이전트 유형을 확장하여 **특정한 요구사항을 충족**하도록 개발자가 직접 기능을 추가하고 정의할 수 있습니다. 예를 들어, 특정 외부 시스템과의 연동이나 고유한 데이터 처리 프로세스를 구현하는 데 활용됩니다.
    2. **세션 (Session):** 사용자와 에이전트 간의 **일련의 대화 내용을 저장하고 관리하는 컨테이너**. 
        - 각 세션은 고유한 ID, 전체 대화 기록, 그리고 현재 에이전트의 상태 정보를 포함합니다.
        -  **세션 서비스**는 이러한 세션의 생성부터 소멸까지 전체 수명 주기를 책임지고 관리합니다. 
        - 또한, **상태 (State) 속성**을 통해 사용자 선호도나 다단계 작업의 진행 상황과 같은 **단기적인 기억을 저장**하여 대화의 맥락을 유지하는 데 중요한 역할을 합니다.
    3. **메모리 (Memory):** 에이전트가 **장기적인 지식을 저장하고 필요시 검색**할 수 있도록 지원하는 기능.
        - **메모리 서비스**는 과거의 대화 기록뿐만 아니라 다양한 형태의 지식을 저장하는 **아카이브 역할**을 수행하며, 에이전트가 필요한 정보를 효율적으로 **수집하고 검색**할 수 있도록 돕습니다. 
        - 이를 통해 에이전트는 시간이 지남에 따라 더욱 똑똑해지고 개인화된 서비스를 제공.
    4. **컨텍스트 (Context):** 에이전트가 작업을 수행하는 데 필요한 **모든 관련 정보를 담고 있는 정보 번들**입니다. 다양한 유형의 컨텍스트를 제공하여 정보 접근 권한과 사용 방식을 제어.
        * **Invocation Context:** 
            - 에이전트 전체에 대한 **포괄적인 접근 권한**을 제공합니다.
        * **Read Only Context:** 
            - 에이전트가 정보에 **안전하게 읽기 전용으로 접근**할 수 있도록 제한합니다. 데이터 보안이 중요한 상황에서 유용합니다.
        * **Callback Context:** 
            - 특정 **라이프사이클 이벤트 (예: 에이전트 시작 또는 종료 시점)** 동안 에이전트의 상태를 수정할 수 있는 권한을 제공합니다.
        * **Tool Context:** 
            - 에이전트가 사용하는 **도구에 필요한 서비스 및 상태 정보에 접근**할 수 있도록 허용합니다. 도구가 원활하게 작동하는 데 필수적입니다.
    5. **멀티 에이전트:** **여러 개의 에이전트를 계층적인 구조 (부모-자식 관계)**로 구성하여 더욱 복잡하고 정교한 작업을 수행할 수 있도록 지원.
        * **단일 부모 규칙:** 
            - 각 자식 에이전트는 **하나의 부모 에이전트만** 가질 수 있도록 하여 책임 관계를 명확하게 함.
        * **통신 메커니즘:** 
            - 부모와 자식 에이전트 간의 효율적인 정보 교환을 위한 다양한 방법을 제공합니다.
            * **공유 세션 상태 (Shared session state):** 
                - 부모와 자식 에이전트가 **동일한 세션의 상태 정보를 공유**하며 협업합니다.
            * **LLM 기반 위임 (LLM-driven delegation):** 
                - 부모 에이전트가 **LLM의 판단에 따라 특정 작업을 자식 에이전트에게 위임**합니다.
            * **명시적 호출 (Explicit invocation):** 
                - 부모 에이전트가 **특정 자식 에이전트를 직접 호출**하여 작업을 지시합니다.
        * **멀티 에이전트 패턴:** 복잡한 문제를 효율적으로 해결하기 위한 다양한 설계 패턴을 제공합니다.
            * **Coordinator/Dispatcher 패턴:** 
                - 하나의 코디네이터 에이전트가 여러 작업자 에이전트에게 작업을 분배하고 결과를 취합.
            * **Sequential Pipeline:** 
                 - 여러 에이전트가 순차적으로 작업을 처리하여 하나의 완성된 결과를 만들어냅니다.
            * **Parallel Processing:** 
                - 여러 에이전트가 독립적인 하위 작업을 동시에 처리하여 전체 작업 시간을 단축합니다.
            * **Hierarchical Task Decomposition:** 
                - 복잡한 작업을 여러 개의 작고 관리 가능한 하위 작업으로 분할하고, 각 하위 작업을 담당하는 에이전트들을 계층적으로 구성합니다.

3.  **실제 예시: 고객 서비스 에이전트**
    * [구글 공식 샘플예제](https://github.com/google/adk-samples/tree/main/agents/customer-service)
    * ADK를 활용하여 **정원용품 소매업체의 고객 서비스 에이전트**를 구축하는 예시.
        * 이 에이전트는 고객의 문의에 응답하고, **제품 검색, 재고 확인, 주문 관리, 심지어 예약 서비스 지원**까지 다양한 작업을 수행할 수 있습니다.
        * **agent.py** 파일에서는 에이전트의 기본적인 정의 (사용할 모델, 기본적인 지침, 사용 가능한 도구 목록 등)를 설정합니다.
        * **config.py** 파일에서는 모델의 종류, 에이전트의 이름 등 다양한 구성 설정을 관리합니다.
        * **prompts.py** 파일에서는 에이전트가 어떤 페르소나를 가지고 어떤 방식으로 행동해야 하는지에 대한 구체적인 지침 (프롬프트)을 정의합니다.

4.  **ADK 실행 및 인터페이스**
    * 개발 편의성을 위해 **CLI (명령줄 인터페이스)**와 **직관적인 웹 인터페이스**를 모두 제공합니다.
    * 특히 웹 인터페이스는 사용자와 에이전트 간의 **채팅 인터페이스**와 에이전트의 내부 상태 (이벤트 발생 내역, 현재 상태 정보 등)를 실시간으로 확인할 수 있는 **메타 스크린**이 분리되어 있어 개발 및 디버깅에 용이합니다.

5.  **ADK의 장점**
    * **단순성:**   
        - 다른 복잡한 프레임워크에 비해 **쉽게 시작**할 수 있으며, 비교적 짧은 시간 안에 **유의미한 결과물**을 만들 수 있습니다.
    * **도구 관리 용이성:** 
        - 새로운 기능을 외부 도구 형태로 쉽게 정의하고 에이전트에 연결할 수 있으며, 에이전트가 이러한 도구를 **효율적으로 활용**하도록 지원합니다.
    * **Google 서비스와의 강력한 연동성:** 
        - Google Cloud Platform의 다양한 서비스와 자연스럽게 통합되어 시너지 효과를 창출합니다.
    * **명확하고 유용한 문서:** 
        - ADK 사용법과 개념을 쉽게 이해할 수 있도록 **잘 정리된 문서**를 제공하여 개발자들이 어려움 없이 학습하고 활용할 수 있도록 돕습니다.

### **2.3 결론**

- Google ADK는 다양한 **에이전트 유형, 체계적인 세션 관리, 장기 기억을 위한 메모리, 상황 인식을 위한 컨텍스트 관리, 그리고 강력한 멀티 에이전트 패턴 지원** 등 정교한 AI 에이전트 시스템 구축에 필요한 **포괄적인 기능**을 제공합니다. 
- 이를 통해 고객 서비스 자동화, 연구 보조, 복잡한 워크플로우 자동화 등 **다양한 산업 분야에 걸쳐 혁신적인 AI 에이전트 솔루션을 개발**할 수 있을 것으로 기대됩니다.

